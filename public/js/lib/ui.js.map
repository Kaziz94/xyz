{
  "version": 3,
  "sources": ["../../public/js/_snowpack/pkg/uhtml.js", "../../public/js/lib/ui/toggleExpanderParent.js", "../../public/js/lib/ui/svg_symbols.js", "../../public/js/lib/ui/style/categorized.js", "../../public/js/lib/ui/style/graduated.js", "../../public/js/lib/ui/style/grid.js", "../../public/js/lib/ui/style/_styles.js", "../../public/js/lib/ui/layerview.js", "../../public/js/lib/ui/listview.js", "../../public/js/lib/ui.js"],
  "sourcesContent": ["var umap = _ => ({\n  // About: get: _.get.bind(_)\n  // It looks like WebKit/Safari didn't optimize bind at all,\n  // so that using bind slows it down by 60%.\n  // Firefox and Chrome are just fine in both cases,\n  // so let's use the approach that works fast everywhere 👍\n  get: key => _.get(key),\n  set: (key, value) => (_.set(key, value), value)\n});\n\nconst attr = /([^\\s\\\\>\"'=]+)\\s*=\\s*(['\"]?)$/;\nconst empty = /^(?:area|base|br|col|embed|hr|img|input|keygen|link|menuitem|meta|param|source|track|wbr)$/i;\nconst node = /<[a-z][^>]+$/i;\nconst notNode = />[^<>]*$/;\nconst selfClosing = /<([a-z]+[a-z0-9:._-]*)([^>]*?)(\\/>)/ig;\nconst trimEnd = /\\s+$/;\n\nconst isNode = (template, i) => (\n    0 < i-- && (\n    node.test(template[i]) || (\n      !notNode.test(template[i]) && isNode(template, i)\n    )\n  )\n);\n\nconst regular = (original, name, extra) => empty.test(name) ?\n                  original : `<${name}${extra.replace(trimEnd,'')}></${name}>`;\n\nvar instrument = (template, prefix, svg) => {\n  const text = [];\n  const {length} = template;\n  for (let i = 1; i < length; i++) {\n    const chunk = template[i - 1];\n    text.push(attr.test(chunk) && isNode(template, i) ?\n      chunk.replace(\n        attr,\n        (_, $1, $2) => `${prefix}${i - 1}=${$2 || '\"'}${$1}${$2 ? '' : '\"'}`\n      ) :\n      `${chunk}<!--${prefix}${i - 1}-->`\n    );\n  }\n  text.push(template[length - 1]);\n  const output = text.join('').trim();\n  return svg ? output : output.replace(selfClosing, regular);\n};\n\nconst {isArray} = Array;\nconst {indexOf, slice} = [];\n\nconst ELEMENT_NODE = 1;\nconst nodeType = 111;\n\nconst remove = ({firstChild, lastChild}) => {\n  const range = document.createRange();\n  range.setStartAfter(firstChild);\n  range.setEndAfter(lastChild);\n  range.deleteContents();\n  return firstChild;\n};\n\nconst diffable = (node, operation) => node.nodeType === nodeType ?\n  ((1 / operation) < 0 ?\n    (operation ? remove(node) : node.lastChild) :\n    (operation ? node.valueOf() : node.firstChild)) :\n  node\n;\n\nconst persistent = fragment => {\n  const {childNodes} = fragment;\n  const {length} = childNodes;\n  if (length < 2)\n    return length ? childNodes[0] : fragment;\n  const nodes = slice.call(childNodes, 0);\n  const firstChild = nodes[0];\n  const lastChild = nodes[length - 1];\n  return {\n    ELEMENT_NODE,\n    nodeType,\n    firstChild,\n    lastChild,\n    valueOf() {\n      if (childNodes.length !== length) {\n        let i = 0;\n        while (i < length)\n          fragment.appendChild(nodes[i++]);\n      }\n      return fragment;\n    }\n  };\n};\n\n/**\n * ISC License\n *\n * Copyright (c) 2020, Andrea Giammarchi, @WebReflection\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE\n * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\n\n/**\n * @param {Node} parentNode The container where children live\n * @param {Node[]} a The list of current/live children\n * @param {Node[]} b The list of future children\n * @param {(entry: Node, action: number) => Node} get\n * The callback invoked per each entry related DOM operation.\n * @param {Node} [before] The optional node used as anchor to insert before.\n * @returns {Node[]} The same list of future children.\n */\nvar udomdiff = (parentNode, a, b, get, before) => {\n  const bLength = b.length;\n  let aEnd = a.length;\n  let bEnd = bLength;\n  let aStart = 0;\n  let bStart = 0;\n  let map = null;\n  while (aStart < aEnd || bStart < bEnd) {\n    // append head, tail, or nodes in between: fast path\n    if (aEnd === aStart) {\n      // we could be in a situation where the rest of nodes that\n      // need to be added are not at the end, and in such case\n      // the node to `insertBefore`, if the index is more than 0\n      // must be retrieved, otherwise it's gonna be the first item.\n      const node = bEnd < bLength ?\n        (bStart ?\n          (get(b[bStart - 1], -0).nextSibling) :\n          get(b[bEnd - bStart], 0)) :\n        before;\n      while (bStart < bEnd)\n        parentNode.insertBefore(get(b[bStart++], 1), node);\n    }\n    // remove head or tail: fast path\n    else if (bEnd === bStart) {\n      while (aStart < aEnd) {\n        // remove the node only if it's unknown or not live\n        if (!map || !map.has(a[aStart]))\n          parentNode.removeChild(get(a[aStart], -1));\n        aStart++;\n      }\n    }\n    // same node: fast path\n    else if (a[aStart] === b[bStart]) {\n      aStart++;\n      bStart++;\n    }\n    // same tail: fast path\n    else if (a[aEnd - 1] === b[bEnd - 1]) {\n      aEnd--;\n      bEnd--;\n    }\n    // The once here single last swap \"fast path\" has been removed in v1.1.0\n    // https://github.com/WebReflection/udomdiff/blob/single-final-swap/esm/index.js#L69-L85\n    // reverse swap: also fast path\n    else if (\n      a[aStart] === b[bEnd - 1] &&\n      b[bStart] === a[aEnd - 1]\n    ) {\n      // this is a \"shrink\" operation that could happen in these cases:\n      // [1, 2, 3, 4, 5]\n      // [1, 4, 3, 2, 5]\n      // or asymmetric too\n      // [1, 2, 3, 4, 5]\n      // [1, 2, 3, 5, 6, 4]\n      const node = get(a[--aEnd], -1).nextSibling;\n      parentNode.insertBefore(\n        get(b[bStart++], 1),\n        get(a[aStart++], -1).nextSibling\n      );\n      parentNode.insertBefore(get(b[--bEnd], 1), node);\n      // mark the future index as identical (yeah, it's dirty, but cheap 👍)\n      // The main reason to do this, is that when a[aEnd] will be reached,\n      // the loop will likely be on the fast path, as identical to b[bEnd].\n      // In the best case scenario, the next loop will skip the tail,\n      // but in the worst one, this node will be considered as already\n      // processed, bailing out pretty quickly from the map index check\n      a[aEnd] = b[bEnd];\n    }\n    // map based fallback, \"slow\" path\n    else {\n      // the map requires an O(bEnd - bStart) operation once\n      // to store all future nodes indexes for later purposes.\n      // In the worst case scenario, this is a full O(N) cost,\n      // and such scenario happens at least when all nodes are different,\n      // but also if both first and last items of the lists are different\n      if (!map) {\n        map = new Map;\n        let i = bStart;\n        while (i < bEnd)\n          map.set(b[i], i++);\n      }\n      // if it's a future node, hence it needs some handling\n      if (map.has(a[aStart])) {\n        // grab the index of such node, 'cause it might have been processed\n        const index = map.get(a[aStart]);\n        // if it's not already processed, look on demand for the next LCS\n        if (bStart < index && index < bEnd) {\n          let i = aStart;\n          // counts the amount of nodes that are the same in the future\n          let sequence = 1;\n          while (++i < aEnd && i < bEnd && map.get(a[i]) === (index + sequence))\n            sequence++;\n          // effort decision here: if the sequence is longer than replaces\n          // needed to reach such sequence, which would brings again this loop\n          // to the fast path, prepend the difference before a sequence,\n          // and move only the future list index forward, so that aStart\n          // and bStart will be aligned again, hence on the fast path.\n          // An example considering aStart and bStart are both 0:\n          // a: [1, 2, 3, 4]\n          // b: [7, 1, 2, 3, 6]\n          // this would place 7 before 1 and, from that time on, 1, 2, and 3\n          // will be processed at zero cost\n          if (sequence > (index - bStart)) {\n            const node = get(a[aStart], 0);\n            while (bStart < index)\n              parentNode.insertBefore(get(b[bStart++], 1), node);\n          }\n          // if the effort wasn't good enough, fallback to a replace,\n          // moving both source and target indexes forward, hoping that some\n          // similar node will be found later on, to go back to the fast path\n          else {\n            parentNode.replaceChild(\n              get(b[bStart++], 1),\n              get(a[aStart++], -1)\n            );\n          }\n        }\n        // otherwise move the source forward, 'cause there's nothing to do\n        else\n          aStart++;\n      }\n      // this node has no meaning in the future list, so it's more than safe\n      // to remove it, and check the next live node out instead, meaning\n      // that only the live list index should be forwarded\n      else\n        parentNode.removeChild(get(a[aStart++], -1));\n    }\n  }\n  return b;\n};\n\nconst aria = node => values => {\n  for (const key in values) {\n    const name = key === 'role' ? key : `aria-${key}`;\n    const value = values[key];\n    if (value == null)\n      node.removeAttribute(name);\n    else\n      node.setAttribute(name, value);\n  }\n};\n\nconst attribute = (node, name) => {\n  let oldValue, orphan = true;\n  const attributeNode = document.createAttributeNS(null, name);\n  return newValue => {\n    if (oldValue !== newValue) {\n      oldValue = newValue;\n      if (oldValue == null) {\n        if (!orphan) {\n          node.removeAttributeNode(attributeNode);\n          orphan = true;\n        }\n      }\n      else {\n        attributeNode.value = newValue;\n        if (orphan) {\n          node.setAttributeNodeNS(attributeNode);\n          orphan = false;\n        }\n      }\n    }\n  };\n};\n\nconst boolean = (node, key, oldValue) => newValue => {\n  if (oldValue !== !!newValue) {\n    // when IE won't be around anymore ...\n    // node.toggleAttribute(key, oldValue = !!newValue);\n    if ((oldValue = !!newValue))\n      node.setAttribute(key, '');\n    else\n      node.removeAttribute(key);\n  }\n};\n\nconst data = ({dataset}) => values => {\n  for (const key in values) {\n    const value = values[key];\n    if (value == null)\n      delete dataset[key];\n    else\n      dataset[key] = value;\n  }\n};\n\nconst event = (node, name) => {\n  let oldValue, type = name.slice(2);\n  if (!(name in node) && name.toLowerCase() in node)\n    type = type.toLowerCase();\n  return newValue => {\n    const info = isArray(newValue) ? newValue : [newValue, false];\n    if (oldValue !== info[0]) {\n      if (oldValue)\n        node.removeEventListener(type, oldValue, info[1]);\n      if (oldValue = info[0])\n        node.addEventListener(type, oldValue, info[1]);\n    }\n  };\n};\n\nconst ref = node => value => {\n  if (typeof value === 'function')\n    value(node);\n  else\n    value.current = node;\n};\n\nconst setter = (node, key) => key === 'dataset' ?\n  data(node) :\n  value => {\n    node[key] = value;\n  };\n\nconst text = node => {\n  let oldValue;\n  return newValue => {\n    if (oldValue != newValue) {\n      oldValue = newValue;\n      node.textContent = newValue == null ? '' : newValue;\n    }\n  };\n};\n\n/*! (c) Andrea Giammarchi - ISC */\nvar createContent = (function (document) {  var FRAGMENT = 'fragment';\n  var TEMPLATE = 'template';\n  var HAS_CONTENT = 'content' in create(TEMPLATE);\n\n  var createHTML = HAS_CONTENT ?\n    function (html) {\n      var template = create(TEMPLATE);\n      template.innerHTML = html;\n      return template.content;\n    } :\n    function (html) {\n      var content = create(FRAGMENT);\n      var template = create(TEMPLATE);\n      var childNodes = null;\n      if (/^[^\\S]*?<(col(?:group)?|t(?:head|body|foot|r|d|h))/i.test(html)) {\n        var selector = RegExp.$1;\n        template.innerHTML = '<table>' + html + '</table>';\n        childNodes = template.querySelectorAll(selector);\n      } else {\n        template.innerHTML = html;\n        childNodes = template.childNodes;\n      }\n      append(content, childNodes);\n      return content;\n    };\n\n  return function createContent(markup, type) {\n    return (type === 'svg' ? createSVG : createHTML)(markup);\n  };\n\n  function append(root, childNodes) {\n    var length = childNodes.length;\n    while (length--)\n      root.appendChild(childNodes[0]);\n  }\n\n  function create(element) {\n    return element === FRAGMENT ?\n      document.createDocumentFragment() :\n      document.createElementNS('http://www.w3.org/1999/xhtml', element);\n  }\n\n  // it could use createElementNS when hasNode is there\n  // but this fallback is equally fast and easier to maintain\n  // it is also battle tested already in all IE\n  function createSVG(svg) {\n    var content = create(FRAGMENT);\n    var template = create('div');\n    template.innerHTML = '<svg xmlns=\"http://www.w3.org/2000/svg\">' + svg + '</svg>';\n    append(content, template.firstChild.childNodes);\n    return content;\n  }\n\n}(document));\n\n// from a generic path, retrieves the exact targeted node\nconst reducePath = ({childNodes}, i) => childNodes[i];\n\n// from a fragment container, create an array of indexes\n// related to its child nodes, so that it's possible\n// to retrieve later on exact node via reducePath\nconst createPath = node => {\n  const path = [];\n  let {parentNode} = node;\n  while (parentNode) {\n    path.push(indexOf.call(parentNode.childNodes, node));\n    node = parentNode;\n    parentNode = node.parentNode;\n  }\n  return path;\n};\n\nconst {createTreeWalker, importNode} = document;\n\n// this \"hack\" tells the library if the browser is IE11 or old Edge\nconst isImportNodeLengthWrong = importNode.length != 1;\n\n// IE11 and old Edge discard empty nodes when cloning, potentially\n// resulting in broken paths to find updates. The workaround here\n// is to import once, upfront, the fragment that will be cloned\n// later on, so that paths are retrieved from one already parsed,\n// hence without missing child nodes once re-cloned.\nconst createFragment = isImportNodeLengthWrong ?\n  (text, type, normalize) => importNode.call(\n    document,\n    createContent(text, type, normalize),\n    true\n  ) :\n  createContent;\n\n// IE11 and old Edge have a different createTreeWalker signature that\n// has been deprecated in other browsers. This export is needed only\n// to guarantee the TreeWalker doesn't show warnings and, ultimately, works\nconst createWalker = isImportNodeLengthWrong ?\n  fragment => createTreeWalker.call(document, fragment, 1 | 128, null, false) :\n  fragment => createTreeWalker.call(document, fragment, 1 | 128);\n\n// this helper avoid code bloat around handleAnything() callback\nconst diff = (comment, oldNodes, newNodes) => udomdiff(\n  comment.parentNode,\n  // TODO: there is a possible edge case where a node has been\n  //       removed manually, or it was a keyed one, attached\n  //       to a shared reference between renders.\n  //       In this case udomdiff might fail at removing such node\n  //       as its parent won't be the expected one.\n  //       The best way to avoid this issue is to filter oldNodes\n  //       in search of those not live, or not in the current parent\n  //       anymore, but this would require both a change to uwire,\n  //       exposing a parentNode from the firstChild, as example,\n  //       but also a filter per each diff that should exclude nodes\n  //       that are not in there, penalizing performance quite a lot.\n  //       As this has been also a potential issue with domdiff,\n  //       and both lighterhtml and hyperHTML might fail with this\n  //       very specific edge case, I might as well document this possible\n  //       \"diffing shenanigan\" and call it a day.\n  oldNodes,\n  newNodes,\n  diffable,\n  comment\n);\n\n// if an interpolation represents a comment, the whole\n// diffing will be related to such comment.\n// This helper is in charge of understanding how the new\n// content for such interpolation/hole should be updated\nconst handleAnything = comment => {\n  let oldValue, text, nodes = [];\n  const anyContent = newValue => {\n    switch (typeof newValue) {\n      // primitives are handled as text content\n      case 'string':\n      case 'number':\n      case 'boolean':\n        if (oldValue !== newValue) {\n          oldValue = newValue;\n          if (!text)\n            text = document.createTextNode('');\n          text.nodeValue = newValue;\n          nodes = diff(comment, nodes, [text]);\n        }\n        break;\n      // null, and undefined are used to cleanup previous content\n      case 'object':\n      case 'undefined':\n        if (newValue == null) {\n          if (oldValue != newValue) {\n            oldValue = newValue;\n            nodes = diff(comment, nodes, []);\n          }\n          break;\n        }\n        // arrays and nodes have a special treatment\n        if (isArray(newValue)) {\n          oldValue = newValue;\n          // arrays can be used to cleanup, if empty\n          if (newValue.length === 0)\n            nodes = diff(comment, nodes, []);\n          // or diffed, if these contains nodes or \"wires\"\n          else if (typeof newValue[0] === 'object')\n            nodes = diff(comment, nodes, newValue);\n          // in all other cases the content is stringified as is\n          else\n            anyContent(String(newValue));\n          break;\n        }\n        // if the new value is a DOM node, or a wire, and it's\n        // different from the one already live, then it's diffed.\n        // if the node is a fragment, it's appended once via its childNodes\n        // There is no `else` here, meaning if the content\n        // is not expected one, nothing happens, as easy as that.\n        if ('ELEMENT_NODE' in newValue && oldValue !== newValue) {\n          oldValue = newValue;\n          nodes = diff(\n            comment,\n            nodes,\n            newValue.nodeType === 11 ?\n              slice.call(newValue.childNodes) :\n              [newValue]\n          );\n        }\n        break;\n      case 'function':\n        anyContent(newValue(comment));\n        break;\n    }\n  };\n  return anyContent;\n};\n\n// attributes can be:\n//  * ref=${...}      for hooks and other purposes\n//  * aria=${...}     for aria attributes\n//  * ?boolean=${...} for boolean attributes\n//  * .dataset=${...} for dataset related attributes\n//  * .setter=${...}  for Custom Elements setters or nodes with setters\n//                    such as buttons, details, options, select, etc\n//  * onevent=${...}  to automatically handle event listeners\n//  * generic=${...}  to handle an attribute just like an attribute\nconst handleAttribute = (node, name/*, svg*/) => {\n  switch (name[0]) {\n    case '?': return boolean(node, name.slice(1), false);\n    case '.': return setter(node, name.slice(1));\n    case 'o': if (name[1] === 'n') return event(node, name);\n  }\n\n  switch (name) {\n    case 'ref': return ref(node);\n    case 'aria': return aria(node);\n  }\n\n  return attribute(node, name/*, svg*/);\n};\n\n// each mapped update carries the update type and its path\n// the type is either node, attribute, or text, while\n// the path is how to retrieve the related node to update.\n// In the attribute case, the attribute name is also carried along.\nfunction handlers(options) {\n  const {type, path} = options;\n  const node = path.reduceRight(reducePath, this);\n  return type === 'node' ?\n    handleAnything(node) :\n    (type === 'attr' ?\n      handleAttribute(node, options.name/*, options.svg*/) :\n      text(node));\n}\n\n// the prefix is used to identify either comments, attributes, or nodes\n// that contain the related unique id. In the attribute cases\n// isµX=\"attribute-name\" will be used to map current X update to that\n// attribute name, while comments will be like <!--isµX-->, to map\n// the update to that specific comment node, hence its parent.\n// style and textarea will have <!--isµX--> text content, and are handled\n// directly through text-only updates.\nconst prefix = 'isµ';\n\n// Template Literals are unique per scope and static, meaning a template\n// should be parsed once, and once only, as it will always represent the same\n// content, within the exact same amount of updates each time.\n// This cache relates each template to its unique content and updates.\nconst cache = umap(new WeakMap);\n\n// a RegExp that helps checking nodes that cannot contain comments\nconst textOnly = /^(?:plaintext|script|style|textarea|title|xmp)$/i;\n\nconst createCache = () => ({\n  stack: [],    // each template gets a stack for each interpolation \"hole\"\n\n  entry: null,  // each entry contains details, such as:\n                //  * the template that is representing\n                //  * the type of node it represents (html or svg)\n                //  * the content fragment with all nodes\n                //  * the list of updates per each node (template holes)\n                //  * the \"wired\" node or fragment that will get updates\n                // if the template or type are different from the previous one\n                // the entry gets re-created each time\n\n  wire: null    // each rendered node represent some wired content and\n                // this reference to the latest one. If different, the node\n                // will be cleaned up and the new \"wire\" will be appended\n});\n\n// the entry stored in the rendered node cache, and per each \"hole\"\nconst createEntry = (type, template) => {\n  const {content, updates} = mapUpdates(type, template);\n  return {type, template, content, updates, wire: null};\n};\n\n// a template is instrumented to be able to retrieve where updates are needed.\n// Each unique template becomes a fragment, cloned once per each other\n// operation based on the same template, i.e. data => html`<p>${data}</p>`\nconst mapTemplate = (type, template) => {\n  const text = instrument(template, prefix, type === 'svg');\n  const content = createFragment(text, type);\n  // once instrumented and reproduced as fragment, it's crawled\n  // to find out where each update is in the fragment tree\n  const tw = createWalker(content);\n  const nodes = [];\n  const length = template.length - 1;\n  let i = 0;\n  // updates are searched via unique names, linearly increased across the tree\n  // <div isµ0=\"attr\" isµ1=\"other\"><!--isµ2--><style><!--isµ3--</style></div>\n  let search = `${prefix}${i}`;\n  while (i < length) {\n    const node = tw.nextNode();\n    // if not all updates are bound but there's nothing else to crawl\n    // it means that there is something wrong with the template.\n    if (!node)\n      throw `bad template: ${text}`;\n    // if the current node is a comment, and it contains isµX\n    // it means the update should take care of any content\n    if (node.nodeType === 8) {\n      // The only comments to be considered are those\n      // which content is exactly the same as the searched one.\n      if (node.nodeValue === search) {\n        nodes.push({type: 'node', path: createPath(node)});\n        search = `${prefix}${++i}`;\n      }\n    }\n    else {\n      // if the node is not a comment, loop through all its attributes\n      // named isµX and relate attribute updates to this node and the\n      // attribute name, retrieved through node.getAttribute(\"isµX\")\n      // the isµX attribute will be removed as irrelevant for the layout\n      // let svg = -1;\n      while (node.hasAttribute(search)) {\n        nodes.push({\n          type: 'attr',\n          path: createPath(node),\n          name: node.getAttribute(search),\n          //svg: svg < 0 ? (svg = ('ownerSVGElement' in node ? 1 : 0)) : svg\n        });\n        node.removeAttribute(search);\n        search = `${prefix}${++i}`;\n      }\n      // if the node was a style, textarea, or others, check its content\n      // and if it is <!--isµX--> then update tex-only this node\n      if (\n        textOnly.test(node.tagName) &&\n        node.textContent.trim() === `<!--${search}-->`\n      ){\n        node.textContent = '';\n        nodes.push({type: 'text', path: createPath(node)});\n        search = `${prefix}${++i}`;\n      }\n    }\n  }\n  // once all nodes to update, or their attributes, are known, the content\n  // will be cloned in the future to represent the template, and all updates\n  // related to such content retrieved right away without needing to re-crawl\n  // the exact same template, and its content, more than once.\n  return {content, nodes};\n};\n\n// if a template is unknown, perform the previous mapping, otherwise grab\n// its details such as the fragment with all nodes, and updates info.\nconst mapUpdates = (type, template) => {\n  const {content, nodes} = (\n    cache.get(template) ||\n    cache.set(template, mapTemplate(type, template))\n  );\n  // clone deeply the fragment\n  const fragment = importNode.call(document, content, true);\n  // and relate an update handler per each node that needs one\n  const updates = nodes.map(handlers, fragment);\n  // return the fragment and all updates to use within its nodes\n  return {content: fragment, updates};\n};\n\n// as html and svg can be nested calls, but no parent node is known\n// until rendered somewhere, the unroll operation is needed to\n// discover what to do with each interpolation, which will result\n// into an update operation.\nconst unroll = (info, {type, template, values}) => {\n  const {length} = values;\n  // interpolations can contain holes and arrays, so these need\n  // to be recursively discovered\n  unrollValues(info, values, length);\n  let {entry} = info;\n  // if the cache entry is either null or different from the template\n  // and the type this unroll should resolve, create a new entry\n  // assigning a new content fragment and the list of updates.\n  if (!entry || (entry.template !== template || entry.type !== type))\n    info.entry = (entry = createEntry(type, template));\n  const {content, updates, wire} = entry;\n  // even if the fragment and its nodes is not live yet,\n  // it is already possible to update via interpolations values.\n  for (let i = 0; i < length; i++)\n    updates[i](values[i]);\n  // if the entry was new, or representing a different template or type,\n  // create a new persistent entity to use during diffing.\n  // This is simply a DOM node, when the template has a single container,\n  // as in `<p></p>`, or a \"wire\" in `<p></p><p></p>` and similar cases.\n  return wire || (entry.wire = persistent(content));\n};\n\n// the stack retains, per each interpolation value, the cache\n// related to each interpolation value, or null, if the render\n// was conditional and the value is not special (Array or Hole)\nconst unrollValues = ({stack}, values, length) => {\n  for (let i = 0; i < length; i++) {\n    const hole = values[i];\n    // each Hole gets unrolled and re-assigned as value\n    // so that domdiff will deal with a node/wire, not with a hole\n    if (hole instanceof Hole)\n      values[i] = unroll(\n        stack[i] || (stack[i] = createCache()),\n        hole\n      );\n    // arrays are recursively resolved so that each entry will contain\n    // also a DOM node or a wire, hence it can be diffed if/when needed\n    else if (isArray(hole))\n      unrollValues(\n        stack[i] || (stack[i] = createCache()),\n        hole,\n        hole.length\n      );\n    // if the value is nothing special, the stack doesn't need to retain data\n    // this is useful also to cleanup previously retained data, if the value\n    // was a Hole, or an Array, but not anymore, i.e.:\n    // const update = content => html`<div>${content}</div>`;\n    // update(listOfItems); update(null); update(html`hole`)\n    else\n      stack[i] = null;\n  }\n  if (length < stack.length)\n    stack.splice(length);\n};\n\n/**\n * Holds all details wrappers needed to render the content further on.\n * @constructor\n * @param {string} type The hole type, either `html` or `svg`.\n * @param {string[]} template The template literals used to the define the content.\n * @param {Array} values Zero, one, or more interpolated values to render.\n */\nfunction Hole(type, template, values) {\n  this.type = type;\n  this.template = template;\n  this.values = values;\n}\n\nconst {create, defineProperties} = Object;\n\n// both `html` and `svg` template literal tags are polluted\n// with a `for(ref[, id])` and a `node` tag too\nconst tag = type => {\n  // both `html` and `svg` tags have their own cache\n  const keyed = umap(new WeakMap);\n  // keyed operations always re-use the same cache and unroll\n  // the template and its interpolations right away\n  const fixed = cache => (template, ...values) => unroll(\n    cache,\n    {type, template, values}\n  );\n  return defineProperties(\n    // non keyed operations are recognized as instance of Hole\n    // during the \"unroll\", recursively resolved and updated\n    (template, ...values) => new Hole(type, template, values),\n    {\n      for: {\n        // keyed operations need a reference object, usually the parent node\n        // which is showing keyed results, and optionally a unique id per each\n        // related node, handy with JSON results and mutable list of objects\n        // that usually carry a unique identifier\n        value(ref, id) {\n          const memo = keyed.get(ref) || keyed.set(ref, create(null));\n          return memo[id] || (memo[id] = fixed(createCache()));\n        }\n      },\n      node: {\n        // it is possible to create one-off content out of the box via node tag\n        // this might return the single created node, or a fragment with all\n        // nodes present at the root level and, of course, their child nodes\n        value: (template, ...values) => unroll(\n          createCache(),\n          {type, template, values}\n        ).valueOf()\n      }\n    }\n  );\n};\n\n// each rendered node gets its own cache\nconst cache$1 = umap(new WeakMap);\n\n// rendering means understanding what `html` or `svg` tags returned\n// and it relates a specific node to its own unique cache.\n// Each time the content to render changes, the node is cleaned up\n// and the new new content is appended, and if such content is a Hole\n// then it's \"unrolled\" to resolve all its inner nodes.\nconst render = (where, what) => {\n  const hole = typeof what === 'function' ? what() : what;\n  const info = cache$1.get(where) || cache$1.set(where, createCache());\n  const wire = hole instanceof Hole ? unroll(info, hole) : hole;\n  if (wire !== info.wire) {\n    info.wire = wire;\n    where.textContent = '';\n    // valueOf() simply returns the node itself, but in case it was a \"wire\"\n    // it will eventually re-append all nodes to its fragment so that such\n    // fragment can be re-appended many times in a meaningful way\n    // (wires are basically persistent fragments facades with special behavior)\n    where.appendChild(wire.valueOf());\n  }\n  return where;\n};\n\nconst html = tag('html');\nconst svg = tag('svg');\n\nexport { html, render, svg };\n", "export function toggleExpanderParent(target, accordion) {\n  const closestExpandable = target.closest(\".expandable\");\n  if (!closestExpandable)\n    return;\n  if (closestExpandable.classList.contains(\"expanded\")) {\n    return closestExpandable.classList.remove(\"expanded\");\n  }\n  if (accordion) {\n    [...closestExpandable.parentElement.children].forEach((sibling) => {\n      sibling.classList.remove(\"expanded\");\n    });\n  }\n  closestExpandable.classList.add(\"expanded\");\n}\n", "export default (marker) => {\n  if (marker.svg && !marker.legend)\n    return marker.svg;\n  const markers = {\n    dot: dot(marker),\n    target: target(marker),\n    triangle: triangle(marker),\n    square: square(marker),\n    semiCircle: semiCircle(marker),\n    markerLetter: markerLetter(marker),\n    markerColor: markerColor(marker),\n    geo: geolocation(),\n    circle: circle(marker),\n    diamond: diamond(marker)\n  };\n  function legend(style) {\n    let _css = `height: ${style.cluster ? 40 : 24}px; width: ${style.cluster ? 40 : 24}px; position: relative;`;\n    const node = html.node`<div style=\"${_css}\">`;\n    function make(m) {\n      let css = `position:absolute; height:${m.cluster ? 40 : 20}px; width:${m.cluster ? 40 : 20}px;`;\n      if (m.svg)\n        return node.appendChild(html.node`<img style=\"${css}\" src=\"${m.svg}\"/>`);\n      if (!m.type)\n        return node.appendChild(html.node`<img style=\"${css}\" src=\"${dot({color: \"#666\"})}\"/>`);\n      return node.appendChild(html.node`<img style=\"${css}\" src=\"${markers[m.type]}\"/>`);\n    }\n    if (style.layers && Array.isArray(style.layers))\n      style.layers.map((_l) => make(_l));\n    else\n      make(style);\n    return node;\n  }\n  if (marker.legend)\n    return legend(marker);\n  if (!marker.type)\n    return dot({\n      color: \"#666\"\n    });\n  return markers[marker.type];\n};\nimport {svg, html} from \"../../_snowpack/pkg/uhtml.js\";\nconst xmlSerializer = new XMLSerializer();\nfunction dot(style) {\n  const icon = svg.node`\n    <svg width=24 height=24 viewBox='0 0 24 24' xmlns='http://www.w3.org/2000/svg'>\n      <circle cx=13 cy=13 r=10 fill='#333'></circle>\n      <circle cx=12 cy=12 r=10 fill=${style.fillColor || \"#fff\"}></circle>`;\n  return `data:image/svg+xml,${encodeURIComponent(xmlSerializer.serializeToString(icon))}`;\n}\nfunction target(style) {\n  const icon = svg.node`\n  <svg width=24 height=24 viewBox='0 0 24 24' xmlns='http://www.w3.org/2000/svg'>\n    <circle cx=13 cy=13 fill='#333' r=10 opacity=0.4></circle>\n    <circle cx=12 cy=12 r=10 fill=${style.fillColor || \"#FFF\"}>`;\n  style.layers && Object.entries(style.layers).forEach((layer) => {\n    icon.appendChild(svg.node`<circle cx=12 cy=12 r=${parseFloat(layer[0]) * 10} fill=${layer[1]}>`);\n  });\n  return `data:image/svg+xml,${encodeURIComponent(xmlSerializer.serializeToString(icon))}`;\n}\nfunction triangle(style) {\n  const icon = svg.node`\n  <svg width=24 height=24 viewBox='${`0 0 24 24`}' xmlns='http://www.w3.org/2000/svg'>\n  <polygon points=\"12,4.68 2,22 22,22\" \n  fill=\"#333\" stroke=\"#333\" opacity=0.4 stroke-opacity=0.4 stroke-width=3\n  stroke-linejoin=\"round\"/>`;\n  icon.appendChild(svg.node`<polygon\n    fill=${style.fillColor || \"#FFF\"} stroke=${style.fillColor || \"#FFF\"} stroke-width=2\n    points=\"12,4.68 2,22 22,22\"  stroke-linejoin=\"round\"/>`);\n  style.layers && Object.entries(style.layers).forEach((layer) => {\n    function x(val, scale) {\n      return 12 + (val - 12) * scale;\n    }\n    function y(val, scale) {\n      return 16 + (val - 16) * scale;\n    }\n    let points = `${x(12, layer[0])},${y(4.68, layer[0])} ${x(2, layer[0])}, ${y(22, layer[0])} ${x(22, layer[0])}, ${y(22, layer[0])}`;\n    icon.appendChild(svg.node`<polygon\n    fill=${layer[1]} stroke=${layer[1] || \"#FFF\"} stroke-width=1\n    points=\"${points}\" stroke-linejoin=\"round\"/>`);\n  });\n  return `data:image/svg+xml,${encodeURIComponent(xmlSerializer.serializeToString(icon))}`;\n}\nfunction square(style) {\n  const icon = svg.node`\n  <svg width=24 height=24 viewBox='0 0 24 24' xmlns='http://www.w3.org/2000/svg'>\n    <rect fill='#333' opacity=0.3 width=20 height=20 x=2 y=2 rx=1></rect>\n    <rect fill=${style.fillColor || \"#FFF\"} width=20 height=20 x=0 y=0 rx=1></rect>`;\n  style.layers && Object.entries(style.layers).forEach((layer) => {\n    icon.appendChild(svg.node`<rect fill=${layer[1]}\n      width=${parseFloat(layer[0]) * 20}\n      height=${parseFloat(layer[0]) * 20}\n      x=${10 * (1 - parseFloat(layer[0]))}\n      y=${10 * (1 - parseFloat(layer[0]))} rx=${parseFloat(layer[0])}></rect>`);\n  });\n  return `data:image/svg+xml,${encodeURIComponent(xmlSerializer.serializeToString(icon))}`;\n}\nfunction diamond(style) {\n  const icon = svg.node`\n  <svg width=24 height=24 viewBox='0 0 24 24' xmlns='http://www.w3.org/2000/svg'>\n  <polygon fill='#333' opacity=0.3\n    points=\"12 0, 24 12, 12 24, 0 12\"\n    ></polygon>\n    <polygon fill=${style.fillColor || \"#FFF\"}\n    points=\"12 0, 24 12, 12 24, 0 12\"\n    ></polygon>`;\n  function s(val, scale) {\n    return 12 + (val - 12) * scale;\n  }\n  style.layers && Object.entries(style.layers).forEach((layer) => {\n    let points = `${s(12, layer[0])} ${s(0, layer[0])},${s(24, layer[0])} ${s(12, layer[0])},${s(12, layer[0])} ${s(24, layer[0])}, ${s(0, layer[0])} ${s(12, layer[0])}`;\n    icon.appendChild(svg.node`\n      <polygon fill=${layer[1] || \"#FFF\"}\n      points=\"${points}\"\n      ></polygon>`);\n  });\n  return `data:image/svg+xml,${encodeURIComponent(xmlSerializer.serializeToString(icon))}`;\n}\nfunction semiCircle(style) {\n  const icon = svg.node`\n  <svg width=30 height=30 viewBox='0 0 20 24' xmlns='http://www.w3.org/2000/svg'>\n    <defs>\n      <clipPath id=\"cut-off-shade\">\n        <rect x=\"0\" y=\"0\" width=\"24\" height=\"11\"/>\n      </clipPath>\n      <clipPath id=\"cut-off\">\n        <rect x=\"0\" y=\"0\" width=\"24\" height=\"10\"/>\n      </clipPath>\n    </defs>\n    <circle cx=\"11\" cy=\"10\" r=\"10\" clip-path=\"url(#cut-off-shade)\" fill=\"#333\" opacity=0.4></circle>\n    <circle cx=10 cy=10 r=10 fill=${style.fillColor || \"#FFF\"} clip-path=\"url(#cut-off-shade)\">`;\n  style.layers && Object.entries(style.layers).forEach((layer) => {\n    icon.appendChild(svg.node`\n    <circle cx=10 cy=10 r=${parseFloat(layer[0]) * 10} fill=${layer[1]} clip-path=\"url(#cut-off-shade)\">`);\n  });\n  return `data:image/svg+xml,${encodeURIComponent(xmlSerializer.serializeToString(icon))}`;\n}\nfunction markerLetter(style) {\n  const icon = svg.node`\n  <svg width=24 height=24 viewBox='0 0 24 24' xmlns='http://www.w3.org/2000/svg'>\n    <path style=\"opacity: 0.5;\" fill=${style.colorMarker}\n      d=\" M 12.692 1.969 C 8.605 1.969 5.334 5.239 5.334 9.328 C 5.334 10.963 5.743 12.189 6.764 14.028 C 8.808 17.504 11.922 21.996 11.922 21.996 C 11.922 21.996 16.576 17.504 18.62 14.028 C 19.642 12.189 20.051 10.963 20.051 9.328 C 20.051 5.239 16.78 1.969 12.692 1.969 Z \"/>\n    <path fill=${style.color}\n      d=\" M 12 1.969 C 7.878 1.969 4.813 5.239 4.813 9.328 C 4.813 10.554 5.222 12.189 6.244 14.028 C 8.289 17.504 12 22 12 22 C 12 22 16.055 17.504 18.099 14.028 C 19.122 12.189 19.341 10.963 19.341 9.328 C 19.341 5.239 16.054 1.969 12 1.969 Z \"/>\n    <circle cx=\"12.17192400568182\" cy=\"8.918683238636365\" r=\"5.109789772727275\" opacity=0.8 fill=\"rgb(255, 255, 255)\"/>\n    <text x=12 y=12 style=\"text-anchor: middle; font-weight: 600; font-size: 10px; font-family: sans-serif; fill: rgb(85, 85, 85);\">\n    ${style.letter}`;\n  return `data:image/svg+xml,${encodeURIComponent(xmlSerializer.serializeToString(icon))}`;\n}\nfunction markerColor(style) {\n  const icon = svg.node`\n  <svg width=18 height=24 viewBox='0 0 24 18' xmlns='http://www.w3.org/2000/svg'>\n    <path style=\"opacity: 0.5;\" fill=${style.colorMarker}\n      d=\"M 10.797 1.238 C 6.308 1.238 2.716 4.83 2.716 9.32 C 2.716 11.116 3.165 12.463 4.287 14.483 C 6.532 18.3 9.952 23.234 9.952 23.234 C 9.952 23.234 15.063 18.3 17.308 14.483 C 18.43 12.463 18.879 11.116 18.879 9.32 C 18.879 4.83 15.287 1.238 10.797 1.238 Z\"/>\n    <path fill=${style.colorMarker}\n      d=\"M 10 1.238 C 5.51 1.238 2.144 4.83 2.144 9.32 C 2.144 10.667 2.593 12.463 3.716 14.483 C 5.961 18.3 10 23.238 10 23.238 C 10 23.238 14.491 18.3 16.736 14.483 C 17.859 12.463 18.1 11.116 18.1 9.32 C 18.1 4.83 14.49 1.238 10 1.238 Z\"/>\n    <circle cx=10.226 cy=8.871 r=5.612 opacity=0.8 fill=\"rgb(255, 255, 255)\"/>\n    <circle cx=10.226 cy=8.871 r=2.806 opacity=0.8 fill=${style.colorDot}/>`;\n  return `data:image/svg+xml,${encodeURIComponent(xmlSerializer.serializeToString(icon))}`;\n}\nfunction geolocation() {\n  const icon = svg.node`\n  <svg width=1000 height=1000 viewBox='0 0 1000 1000' xmlns='http://www.w3.org/2000/svg'>\n    <circle cx=500 cy=500 r=350 stroke='#1F964D' opacity=0.8 stroke-width=75 fill=none></circle>\n    <circle cx=500 cy=500 r=200 fill='#1F964D' opacity=0.8></circle>\n    <path stroke='#1F964D' opacity=0.8 stroke-width=75 d=\"M500,150L500,0M500,850L500,1000M0,500L150,500M850,500L1000,500\" />`;\n  return `data:image/svg+xml,${encodeURIComponent(xmlSerializer.serializeToString(icon))}`;\n}\nfunction circle(style) {\n  const icon = svg.node`\n  <svg width=24 height=24 viewBox='0 0 30 30' xmlns='http://www.w3.org/2000/svg'>\n    <circle cx=16 cy=16 r=10\n      stroke=\"#333\"\n      stroke-width=\"${style.strokeWidth || 1}\"\n      fill=\"none\"></circle>\n    <circle cx=15 cy=15 r=10\n      stroke=\"${style.strokeColor || \"#333\"}\"\n      stroke-width=\"${style.strokeWidth || 1}\"\n      fill=\"${style.fillColor || \"none\"}\"></circle>`;\n  return `data:image/svg+xml,${encodeURIComponent(xmlSerializer.serializeToString(icon))}`;\n}\n", "import {svg, html} from \"../../../_snowpack/pkg/uhtml.js\";\nimport svg_symbols from \"../svg_symbols.js\";\nexport default (layer) => {\n  const theme = layer.style.theme;\n  const legend = html.node`<div class=\"legend grid\">`;\n  legend.appendChild(html.node`\n    <div\n      class=\"switch-all label\"\n      style=\"grid-column: 1/3;\">\n        ${mapp_dictionary.layer_style_switch_caption}\n      <a\n        class=\"primary-colour\"\n        style=\"cursor: pointer;\"\n        onclick=${(e) => {\n    e.stopPropagation();\n    legend.querySelectorAll(\".switch\").forEach((_switch) => _switch.click());\n    layer.reload();\n  }}>${mapp_dictionary.layer_style_switch_all}</a>.`);\n  if (!layer.filter.current[theme.field]) {\n    layer.filter.current[theme.field] = {};\n  }\n  Object.entries(theme.cat).forEach((cat) => {\n    const cat_style = Object.assign({}, layer.style.default, cat[1].style && cat[1].style.marker || cat[1].style || cat[1]);\n    if (cat_style.svg || cat_style.type) {\n      legend.appendChild(svg_symbols(Object.assign({legend: true}, cat_style)));\n    } else if (cat_style.fillOpacity === void 0) {\n      legend.appendChild(svg.node`\n      <svg height=24 width=24>\n      <line\n        x1=0 y1=12 x2=24 y2=12\n        stroke=${cat_style.strokeColor}\n        stroke-width=${cat_style.strokeWidth || 1}>`);\n    } else {\n      legend.appendChild(svg.node`\n      <svg height=24 width=24>\n      <rect\n        width=24 height=24\n        fill=${cat_style.fillColor || \"#FFF\"}\n        fill-opacity=${cat_style.fillOpacity}\n        stroke=${cat_style.strokeColor}\n        stroke-width=${cat_style.strokeWidth || 1}>`);\n    }\n    legend.appendChild(html.node`\n    <div\n      class=\"label switch\"\n      onclick=${(e) => {\n      e.stopPropagation();\n      e.target.classList.toggle(\"disabled\");\n      if (e.target.classList.contains(\"disabled\")) {\n        if (!layer.filter.current[theme.field].ni) {\n          layer.filter.current[theme.field].ni = [];\n        }\n        layer.filter.current[theme.field].ni.push(cat[0]);\n      } else {\n        layer.filter.current[theme.field].ni.splice(layer.filter.current[theme.field].ni.indexOf(cat[0]), 1);\n        if (!layer.filter.current[theme.field].ni.length) {\n          delete layer.filter.current[theme.field].ni;\n        }\n      }\n      layer.reload();\n    }}>${cat[1].label || cat[0]}`);\n  });\n  if (layer.style.cluster) {\n    legend.appendChild(svg_symbols(Object.assign({legend: true, cluster: true}, layer.style.cluster)));\n    legend.appendChild(html.node`\n    <div class=\"label\" style=\"alignment-baseline:central;\">${mapp_dictionary.layer_style_cluster}`);\n  }\n  return legend;\n};\n", "import {svg, html} from \"../../../_snowpack/pkg/uhtml.js\";\nimport svg_symbols from \"../svg_symbols.js\";\nexport default (layer) => {\n  const legend = html.node`<div class=\"legend grid\">`;\n  layer.style.theme.cat_arr.forEach((cat) => {\n    const cat_style = Object.assign({}, layer.style.default, cat.style && cat.style.marker || cat.style || cat);\n    if (cat_style.svg || cat_style.type) {\n      legend.appendChild(svg_symbols(Object.assign({legend: true}, cat_style)));\n    } else if (cat_style.fillOpacity === void 0) {\n      legend.appendChild(svg.node`\n      <svg height=24 width=24>\n      <line\n        x1=0 y1=12 x2=24 y2=12\n        stroke=${cat_style.strokeColor}\n        stroke-width=${cat_style.strokeWidth || 1}>`);\n    } else {\n      legend.appendChild(svg.node`\n      <svg height=24 width=24>\n      <rect\n        width=24 height=24\n        fill=${cat_style.fillColor || \"#FFF\"}\n        fill-opacity=${cat_style.fillOpacity}\n        stroke=${cat_style.strokeColor}\n        stroke-width=${cat_style.strokeWidth || 1}>`);\n    }\n    legend.appendChild(html.node`\n    <div  style=\"grid-column: 2\" class=\"label\">${cat.label || cat.value}`);\n  });\n  return legend;\n};\n", "import {svg, html} from \"../../../_snowpack/pkg/uhtml.js\";\nexport default (layer) => {\n  const legend = html.node`<div class=\"legend\">`;\n  legend.appendChild(html.node`\n  <button class=\"btn-drop\">\n  <div\n    class=\"head\"\n    onclick=${(e) => {\n    e.preventDefault();\n    e.target.parentElement.classList.toggle(\"active\");\n  }}>\n    <span>${Object.keys(layer.grid_fields)[0]}</span>\n    <div class=\"icon\"></div>\n  </div>\n  <ul>\n    ${Object.entries(layer.grid_fields).map((keyVal) => html`\n        <li onclick=${(e) => {\n    const drop = e.target.closest(\".btn-drop\");\n    drop.classList.toggle(\"active\");\n    drop.querySelector(\":first-child\").textContent = keyVal[0];\n    layer.grid_size = keyVal[1];\n    layer.reload();\n  }}>${keyVal[0]}`)}`);\n  const _svg = legend.appendChild(svg.node`<svg width=100% height=100px>`);\n  legend.appendChild(html.node`\n  <button class=\"btn-drop\">\n  <div\n    class=\"head\"\n    onclick=${(e) => {\n    e.preventDefault();\n    e.target.parentElement.classList.toggle(\"active\");\n  }}>\n    <span>${Object.keys(layer.grid_fields)[1]}</span>\n    <div class=\"icon\"></div>\n  </div>\n  <ul>\n    ${Object.entries(layer.grid_fields).map((keyVal) => html`\n      <li onclick=${(e) => {\n    const drop = e.target.closest(\".btn-drop\");\n    drop.classList.toggle(\"active\");\n    drop.querySelector(\":first-child\").textContent = keyVal[0];\n    layer.grid_color = keyVal[1];\n    layer.reload();\n  }}>${keyVal[0]}`)}`);\n  let yTrack = 38, n = layer.style.range.length, w = 100 / n;\n  for (let i = 0; i < n; i++) {\n    let r = (i + 2) * 10 / n, x = i * w;\n    _svg.appendChild(svg.node`\n    <circle\n      fill='#777'\n      cx='${x + w / 2 + 1 + \"%\"}'\n      cy='${yTrack + 1}'\n      r='${r}'/>\n    <circle\n      fill='${layer.style.hxcolor || \"#999\"}'\n      cx='${x + w / 2 + \"%\"}'\n      cy='${yTrack}'\n      r='${r}'/>`);\n    if (i === 0) {\n      legend.size_min = _svg.appendChild(svg.node`\n      <text\n        class='label'\n        style='text-anchor: start;'\n        x=${x + \"%\"}\n        y=${yTrack - 20}>${mapp_dictionary.layer_grid_legend_min}`);\n    }\n    if (i === (n / 2 % 1 != 0 && Math.round(n / 2) - 1)) {\n      legend.size_avg = _svg.appendChild(svg.node`\n      <text\n        class='label'\n        style='text-anchor: middle;'\n        x=${x + w / 2 + \"%\"}\n        y=${yTrack - 20}>${mapp_dictionary.layer_grid_legend_avg}`);\n    }\n    if (i === n - 1) {\n      legend.size_max = _svg.appendChild(svg.node`\n      <text\n        class='label'\n        style='text-anchor: end;'\n        x=${x + w + \"%\"}\n        y=${yTrack - 20}>${mapp_dictionary.layer_grid_legend_max}`);\n    }\n  }\n  yTrack += 20;\n  for (let i = 0; i < n; i++) {\n    let x = i * w;\n    _svg.appendChild(svg.node`\n    <rect\n      height=20\n      width=${w + \"%\"}\n      x=${x + \"%\"}\n      y=${yTrack}\n      fill=${layer.style.range[i]}`);\n    if (i === 0) {\n      legend.color_min = _svg.appendChild(svg.node`\n      <text\n        class='label'\n        style='text-anchor: start;'\n        x=${x + \"%\"}\n        y=${yTrack + 40}>${mapp_dictionary.layer_grid_legend_min}`);\n    }\n    if (i === (n / 2 % 1 != 0 && Math.round(n / 2) - 1)) {\n      legend.color_avg = _svg.appendChild(svg.node`\n      <text\n        class='label'\n        style='text-anchor: middle;'\n        x=${x + w / 2 + \"%\"}\n        y=${yTrack + 40}>${mapp_dictionary.layer_grid_legend_avg}`);\n    }\n    if (i === n - 1) {\n      legend.color_max = _svg.appendChild(svg.node`\n      <text\n        class='label'\n        style='text-anchor: end;'\n        x=${x + w + \"%\"}\n        y=${yTrack + 40}>${mapp_dictionary.layer_grid_legend_max}`);\n    }\n  }\n  legend.appendChild(html.node`\n  <td style=\"padding-top: 5px;\" colSpan=2>\n  <label class=\"input-checkbox\">\n  <input type=\"checkbox\"\n    onchange=${(e) => {\n    layer.grid_ratio = e.target.checked;\n    layer.reload();\n  }}>\n  </input>\n  <div></div><span>${mapp_dictionary.layer_grid_legend_ratio}`);\n  return legend;\n};\n", "import categorized from \"./categorized.js\";\nimport graduated from \"./graduated.js\";\nimport grid from \"./grid.js\";\nimport bivariate from \"./bivariate.js\";\nimport dynamic from \"./dynamic.js\";\nimport basic from \"./basic.js\";\nimport {html} from \"../../../_snowpack/pkg/uhtml.js\";\nimport {toggleExpanderParent} from \"../toggleExpanderParent.js\";\nconst themes = {\n  categorized,\n  graduated,\n  grid\n};\nexport default (layer) => {\n  if (!layer.style)\n    return;\n  if (layer.style.hidden)\n    return;\n  if (!layer.style.theme && !layer.style.label)\n    return;\n  const panel = layer.view.appendChild(html.node`\n      <div class=\"drawer panel expandable\">`);\n  panel.appendChild(html.node`\n    <div\n      class=\"header primary-colour\"\n      onclick=${(e) => {\n    e.stopPropagation();\n    toggleExpanderParent(e.target, true);\n  }}>\n      <span>${mapp_dictionary.layer_style_header}</span>\n      <button class=\"btn-header xyz-icon icon-expander primary-colour-filter\">`);\n  layer.style.themes && panel.appendChild(html.node`\n      <div>${mapp_dictionary.layer_style_select_theme}</div>\n      <button class=\"btn-drop\">\n      <div\n        class=\"head\"\n        onclick=${(e) => {\n    e.preventDefault();\n    e.target.parentElement.classList.toggle(\"active\");\n  }}>\n        <span>${Object.keys(layer.style.themes)[0]}</span>\n        <div class=\"icon\"></div>\n      </div>\n      <ul>\n        ${Object.entries(layer.style.themes).map((theme) => html.node`\n          <li onclick=${(e) => {\n    const drop = e.target.closest(\".btn-drop\");\n    drop.querySelector(\"span\").textContent = theme[0];\n    drop.classList.toggle(\"active\");\n    layer.style.theme = theme[1];\n    applyTheme(layer);\n    layer.reload();\n  }}>${theme[0]}`)}`);\n  layer.style.bringToFront = html.node`\n      <button \n        title=${mapp_dictionary.layer_style_bring_to_front}\n        style=\"margin-top: 5px;\"\n        class=\"btn-wide primary-colour\"\n        onclick=${() => layer.bringToFront()}>${mapp_dictionary.layer_style_bring_to_front}`;\n  if (!layer.style.theme && layer.style.label)\n    panel.appendChild(layer.style.bringToFront);\n  if (layer.style.theme)\n    applyTheme(layer);\n  return panel;\n  function applyTheme(layer2) {\n    layer2.style.legend && layer2.style.legend.remove();\n    layer2.style.bringToFront.remove();\n    if (layer2.style.theme && !layer2.style.theme.type)\n      return;\n    layer2.style.legend = legend(layer2);\n    panel.appendChild(layer2.style.legend);\n    panel.appendChild(layer2.style.bringToFront);\n  }\n  function legend(layer2) {\n    layer2.style.legend = html.node`<div class=\"legend\">`;\n    layer2.filter = layer2.filter || {};\n    return themes[layer2.style.theme.type](layer2);\n  }\n};\n", "import {html} from \"../../_snowpack/pkg/uhtml.js\";\nimport {toggleExpanderParent} from \"./toggleExpanderParent.js\";\nimport style from \"./style/_styles.js\";\nexport default (layer) => {\n  layer.view = html.node`<div class=\"drawer layer-view\">`;\n  const header = layer.view.appendChild(html.node`\n    <div class=\"header enabled\"><span>${layer.name || layer.key}`);\n  header.appendChild(html.node`\n    <button\n      title=${mapp_dictionary.layer_zoom_to_extent}\n      class=\"btn-header xyz-icon icon-fullscreen\"\n      onclick=${(e) => {\n    e.stopPropagation();\n    layer.zoomToExtent();\n  }}>`);\n  const toggleDisplay = header.appendChild(html.node`\n    <button\n      title=${mapp_dictionary.layer_visibility}\n      class=\"${`btn-header xyz-icon icon-toggle ${layer.display && \"on\" || \"off\"}`}\"\n      onclick=${(e) => {\n    e.stopPropagation();\n    layer.display ? layer.remove() : layer.show();\n  }}>`);\n  layer.view.addEventListener(\"display-on\", () => {\n    toggleDisplay.classList.add(\"on\");\n  });\n  layer.view.addEventListener(\"display-off\", () => {\n    toggleDisplay.classList.remove(\"on\");\n  });\n  if (layer.meta) {\n    const meta = layer.view.appendChild(html.node`<p class=\"meta\">`);\n    meta.innerHTML = layer.meta;\n  }\n  style(layer);\n  if (layer.view.children.length <= 1)\n    return;\n  layer.view.classList.add(\"expandable\");\n  header.onclick = (e) => {\n    e.stopPropagation();\n    toggleExpanderParent(e.target, true);\n  };\n  header.appendChild(html.node`\n  <button\n    title=${mapp_dictionary.layer_toggle_dashboard}\n    class=\"btn-header xyz-icon icon-expander\"\n    onclick=${(e) => {\n    e.stopPropagation();\n    toggleExpanderParent(e.target);\n  }}>`);\n};\n", "import layerview from \"./layerview.js\";\nimport {html} from \"../../_snowpack/pkg/uhtml.js\";\nimport {toggleExpanderParent} from \"./toggleExpanderParent.js\";\nexport default (params) => {\n  const listview = {\n    node: params.target,\n    groups: {}\n  };\n  params.list.forEach((layer) => {\n    if (layer.hidden)\n      return;\n    layerview(layer);\n    if (!layer.group) {\n      listview.node.appendChild(layer.view);\n      return;\n    }\n    if (!listview.groups[layer.group])\n      createGroup(layer);\n    listview.groups[layer.group].addLayer(layer);\n  });\n  function createGroup(layer) {\n    const group = {\n      list: []\n    };\n    listview.groups[layer.group] = group;\n    const drawer = listview.node.appendChild(html.node`<div class=\"drawer layer-group expandable\">`);\n    const header = drawer.appendChild(html.node`\n      <div\n        class=\"header enabled\"\n        onclick=${(e) => {\n      e.stopPropagation();\n      toggleExpanderParent(e.target, true);\n    }}>\n        <span>${layer.group}`);\n    const meta = drawer.appendChild(html.node`<div class=\"meta\">`);\n    group.chkVisibleLayer = () => {\n      group.list.some((layer2) => layer2.display) ? hideLayers.classList.add(\"on\") : hideLayers.classList.remove(\"on\");\n    };\n    group.addLayer = (layer2) => {\n      if (layer2.groupmeta) {\n        const metaContent = meta.appendChild(html.node`<div>`);\n        metaContent.innerHTML = layer2.groupmeta;\n      }\n      group.list.push(layer2);\n      drawer.appendChild(layer2.view);\n      group.chkVisibleLayer();\n      layer2.view.addEventListener(\"display-on\", group.chkVisibleLayer);\n      layer2.view.addEventListener(\"display-off\", group.chkVisibleLayer);\n    };\n    const hideLayers = header.appendChild(html.node`\n        <button\n          class=\"btn-header xyz-icon icon-toggle\"\n          title=${mapp_dictionary.layer_group_hide_layers}\n          onclick=${(e) => {\n      e.stopPropagation();\n      e.target.classList.toggle(\"on\");\n      if (e.target.classList.contains(\"on\")) {\n        group.list.filter((layer2) => !layer2.display).forEach((layer2) => layer2.show());\n        return;\n      }\n      group.list.filter((layer2) => layer2.display).forEach((layer2) => layer2.remove());\n    }}>`);\n    header.appendChild(html.node`\n        <button \n          class=\"xyz-icon btn-header icon-expander\"\n          title=${mapp_dictionary.layer_group_toggle}\n          onclick=${(e) => {\n      e.stopPropagation();\n      toggleExpanderParent(e.target);\n    }}>`);\n  }\n};\n", "import listview from \"./ui/listview.js\";\nimport layerview from \"./ui/layerview.js\";\nconst mapp_ui = {\n  listview,\n  layerview\n};\nwindow.mapp_ui = mapp_ui;\nexport default mapp_ui;\n"],
  "mappings": "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",
  "names": []
}
